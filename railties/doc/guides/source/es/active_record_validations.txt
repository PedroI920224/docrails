== 2.9 presence
Este ayudante valida que los atributos especificados no estén vacíos. Utiliza el metodo blank? para comprobar si el valor es nil o una cadena esta en blanco, es decir, una cadena que está vacía o consta de espacios en blanco.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :name, :login, :email, presence: true
end
-------------------------------------------------------

Si desea estar seguro de que una asociación está presente, deberá probar si el objeto asociado está presente y no la clave externa utilizada para asignar la asociación.

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, presence: true
end
-------------------------------------------------------

En el modelo order, para validar los registros asociados cuya presencia es necesaria, debe especificar la opción :inverse_of para la asociación:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end
-------------------------------------------------------

Si valida la presencia de un objeto asociado a través de una relación has_one o has_many, comprobará que el objeto no está en blank? Ni marked_for_destruction?

Desde false.blank? Es true, si desea validar la presencia de un campo booleano debe utilizar una de las siguientes validaciones:

[source, ruby]
-------------------------------------------------------
validates :boolean_field_name, presence: true
validates :boolean_field_name, inclusion: { in: [true, false] }
validates :boolean_field_name, exclusion: { in: [nil] }
-------------------------------------------------------

Mediante el uso de una de estas validaciones, se asegurará de que el valor NO será nil lo que resultaría en un valor NULL en la mayoría de los casos.

== 2.10 absence
Este ayudante valida que los atributos especificados están ausentes. Utiliza el metodo present? para comprobar si el valor no es nil o una cadena en blanco, es decir, una cadena que está vacía o consta de espacios en blanco.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :name, :login, :email, absence: true
end
-------------------------------------------------------

Si desea estar seguro de que una asociación está ausente, deberá probar si el objeto asociado está ausente y no la clave externa utilizada para asignar la asociación.

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, absence: true
end
-------------------------------------------------------

Para validar los registros asociados cuyo absence es necesario, debe especificar la opción: inverse_of para la asociación:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end
-------------------------------------------------------

Si valida la ausencia de un objeto asociado a través de una relación has_one o has_many, comprobará que el objeto no está present? Ni marked_for_destruction?.

Desde false.present? Es falso, si desea validar la ausencia de un campo booleano que debe utilizar un validador :field_name, exclusion: { in: [true, false] }.

El mensaje de error predeterminado es "must be blank".

== 2.11 uniqueness
Este ayudante valida que el valor del atributo es único justo antes de que el objeto sea guardado. No crea una restricción de unicidad en la base de datos, por lo que puede suceder que dos conexiones de base de datos diferentes creen dos registros con el mismo valor para una columna que desea ser único. Para evitarlo, debe crear un índice único en ambas columnas de la base de datos. Consulte el manual de MySQL para obtener más detalles sobre varios índices de columnas.

[source, ruby]
-------------------------------------------------------
class Account < ActiveRecord::Base
  validates :email, uniqueness: true
end
-------------------------------------------------------

La validación ocurre realizando una consulta SQL en la tabla del modelo, buscando un registro existente con el mismo valor en ese atributo.

Hay una opción de :scope que puede utilizar para especificar otros atributos que se utilizan para limitar la comprobación de unicidad:

[source, ruby]
-------------------------------------------------------
class Holiday < ActiveRecord::Base
  validates :name, uniqueness: { scope: :year,
    message: ""should happen once per year"" }
end
-------------------------------------------------------

También hay una opción: case_sensitive que puede utilizar para definir si la restricción de unicidad será sensible a mayúsculas o minúsculas. Esta opción predeterminada es true.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :name, uniqueness: { case_sensitive: false }
end
-------------------------------------------------------

Tenga en cuenta que algunas bases de datos están configuradas para realizar búsquedas sin distinción entre mayúsculas y minúsculas.

El mensaje de error predeterminado es "has already been taken".

==2.12 validates_with
Este ayudante pasa el registro a una clase separada para su validación.

[source, ruby]
-------------------------------------------------------
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == ""Evil""
      record.errors[:base] << ""This person is evil""
    end
  end
end

class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end
-------------------------------------------------------

Los errores añadidos a record.errors [:base] se refieren al estado del registro como un todo y no a un atributo específico.

El ayudante validates_with toma una clase, o una lista de clases para utilizar para la validación. No hay un mensaje de error predeterminado para validates_with. Debe agregar manualmente errores a la colección de errores del registro en la clase validator.

Para implementar el método validate, debe tener definido un parámetro record, que es el registro a validar.

Como todas las demás validaciones, validates_with toma las opciones: if,: unless y: on. Si pasa otras opciones, enviará las opciones a la clase validator como options:

[source, ruby]
-------------------------------------------------------
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == ""Evil"" }
      record.errors[:base] << ""This person is evil""
    end
  end
end

class Person < ActiveRecord::Base
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end
-------------------------------------------------------

Tenga en cuenta que el validador se inicializará sólo una vez para todo el ciclo de vida de la aplicación, y no en cada ejecución de validación, así que tenga cuidado al usar variables de instancia dentro de ella.

Si su validador es lo suficientemente complejo como para que desee variables de instancia, puede utilizar fácilmente un objeto Ruby antiguo:

==2.13 validates_each
Este ayudante valida atributos contra un bloque. No tiene una función de validación predefinida. Deberías crear uno usando un bloque, y cada atributo pasado a validates_each será probado. En el ejemplo siguiente, no queremos que los nombres y apellidos comiencen con minúsculas.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/
  end
end
-------------------------------------------------------

El bloque recibe el registro, el nombre del atributo y el valor del atributo. Puede hacer cualquier cosa que desee para buscar datos válidos dentro del bloque. Si la validación falla, debe agregar un mensaje de error al modelo, por lo que no es válido.
