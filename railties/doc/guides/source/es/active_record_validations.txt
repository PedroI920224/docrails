== 2.9 presence
Este ayudante valida que los atributos especificados no estén vacíos. Utiliza el metodo blank? para comprobar si el valor es nil o una cadena esta en blanco, es decir, una cadena que está vacía o consta de espacios en blanco.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :name, :login, :email, presence: true
end
-------------------------------------------------------

Si desea estar seguro de que una asociación está presente, deberá probar si el objeto asociado está presente y no la clave externa utilizada para asignar la asociación.

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, presence: true
end
-------------------------------------------------------

En el modelo order, para validar los registros asociados cuya presencia es necesaria, debe especificar la opción :inverse_of para la asociación:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end
-------------------------------------------------------

Si valida la presencia de un objeto asociado a través de una relación has_one o has_many, comprobará que el objeto no está en blank? Ni marked_for_destruction?

Desde false.blank? Es true, si desea validar la presencia de un campo booleano debe utilizar una de las siguientes validaciones:

[source, ruby]
-------------------------------------------------------
validates :boolean_field_name, presence: true
validates :boolean_field_name, inclusion: { in: [true, false] }
validates :boolean_field_name, exclusion: { in: [nil] }
-------------------------------------------------------

Mediante el uso de una de estas validaciones, se asegurará de que el valor NO será nil lo que resultaría en un valor NULL en la mayoría de los casos.

== 2.10 absence
Este ayudante valida que los atributos especificados están ausentes. Utiliza el metodo present? para comprobar si el valor no es nil o una cadena en blanco, es decir, una cadena que está vacía o consta de espacios en blanco.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :name, :login, :email, absence: true
end
-------------------------------------------------------

Si desea estar seguro de que una asociación está ausente, deberá probar si el objeto asociado está ausente y no la clave externa utilizada para asignar la asociación.

[source, ruby]
-------------------------------------------------------
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, absence: true
end
-------------------------------------------------------

Para validar los registros asociados cuyo absence es necesario, debe especificar la opción: inverse_of para la asociación:

[source, ruby]
-------------------------------------------------------
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end
-------------------------------------------------------

Si valida la ausencia de un objeto asociado a través de una relación has_one o has_many, comprobará que el objeto no está present? Ni marked_for_destruction?.

Desde false.present? Es falso, si desea validar la ausencia de un campo booleano que debe utilizar un validador :field_name, exclusion: { in: [true, false] }.

El mensaje de error predeterminado es "must be blank".

== 2.11 uniqueness
Este ayudante valida que el valor del atributo es único justo antes de que el objeto sea guardado. No crea una restricción de unicidad en la base de datos, por lo que puede suceder que dos conexiones de base de datos diferentes creen dos registros con el mismo valor para una columna que desea ser único. Para evitarlo, debe crear un índice único en ambas columnas de la base de datos. Consulte el manual de MySQL para obtener más detalles sobre varios índices de columnas.

[source, ruby]
-------------------------------------------------------
class Account < ActiveRecord::Base
  validates :email, uniqueness: true
end
-------------------------------------------------------

La validación ocurre realizando una consulta SQL en la tabla del modelo, buscando un registro existente con el mismo valor en ese atributo.

Hay una opción de :scope que puede utilizar para especificar otros atributos que se utilizan para limitar la comprobación de unicidad:

[source, ruby]
-------------------------------------------------------
class Holiday < ActiveRecord::Base
  validates :name, uniqueness: { scope: :year,
    message: ""should happen once per year"" }
end
-------------------------------------------------------

También hay una opción: case_sensitive que puede utilizar para definir si la restricción de unicidad será sensible a mayúsculas o minúsculas. Esta opción predeterminada es true.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :name, uniqueness: { case_sensitive: false }
end
-------------------------------------------------------

Tenga en cuenta que algunas bases de datos están configuradas para realizar búsquedas sin distinción entre mayúsculas y minúsculas.

El mensaje de error predeterminado es "has already been taken".

==2.12 validates_with
Este ayudante pasa el registro a una clase separada para su validación.

[source, ruby]
-------------------------------------------------------
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == ""Evil""
      record.errors[:base] << ""This person is evil""
    end
  end
end

class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end
-------------------------------------------------------

Los errores añadidos a record.errors [:base] se refieren al estado del registro como un todo y no a un atributo específico.

El ayudante validates_with toma una clase, o una lista de clases para utilizar para la validación. No hay un mensaje de error predeterminado para validates_with. Debe agregar manualmente errores a la colección de errores del registro en la clase validator.

Para implementar el método validate, debe tener definido un parámetro record, que es el registro a validar.

Como todas las demás validaciones, validates_with toma las opciones: if,: unless y: on. Si pasa otras opciones, enviará las opciones a la clase validator como options:

[source, ruby]
-------------------------------------------------------
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == ""Evil"" }
      record.errors[:base] << ""This person is evil""
    end
  end
end

class Person < ActiveRecord::Base
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end
-------------------------------------------------------

Tenga en cuenta que el validador se inicializará sólo una vez para todo el ciclo de vida de la aplicación, y no en cada ejecución de validación, así que tenga cuidado al usar variables de instancia dentro de ella.

Si su validador es lo suficientemente complejo como para que desee variables de instancia, puede utilizar fácilmente un objeto Ruby antiguo:

==2.13 validates_each
Este ayudante valida atributos contra un bloque. No tiene una función de validación predefinida. Deberías crear uno usando un bloque, y cada atributo pasado a validates_each será probado. En el ejemplo siguiente, no queremos que los nombres y apellidos comiencen con minúsculas.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/
  end
end
-------------------------------------------------------

El bloque recibe el registro, el nombre del atributo y el valor del atributo. Puede hacer cualquier cosa que desee para buscar datos válidos dentro del bloque. Si la validación falla, debe agregar un mensaje de error al modelo, por lo que no es válido.

==3 Common Validation Options
Estas son las opciones comunes de validación:

3.1 :allow_nil

La opción: allow_nil omite la validación cuando el valor que se valida es nil.

[source, ruby]
-------------------------------------------------------
class Coffee < ActiveRecord::Base
  validates :size, inclusion: { in: %w(small medium large),
    message: ""%{value} is not a valid size"" }, allow_nil: true
end
-------------------------------------------------------

3.2 :allow_blank
La opción: allow_blank es similar a la opción: allow_nil. Esta opción permitirá que la validación pase si el valor del atributo está en blank?, como nil o una cadena vacía por ejemplo.

[source, ruby]
-------------------------------------------------------
class Topic < ActiveRecord::Base
  validates :title, length: { is: 5 }, allow_blank: true
end

Topic.create(title: """").valid?  # => true
Topic.create(title: nil).valid? # => true
-------------------------------------------------------

3.3 :message
Como ya lo ha visto, la opción: message le permite especificar el mensaje que se agregará a la colección de errores cuando la validación falle. Cuando no se utiliza esta opción, Active Record utilizará el mensaje de error predeterminado respectivo para cada ayudante de validación.

3.4 :on
La opción :on permite especificar cuándo debe ocurrir la validación. El comportamiento predeterminado de todos los ayudantes de validación incorporados se ejecutará en la función Guardar (tanto cuando se crea un nuevo registro como cuando se está actualizando). Si desea cambiarlo, puede utilizar on::create para ejecutar la validación sólo cuando se crea un nuevo registro o on::update para ejecutar la validación sólo cuando se actualice un registro.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  # it will be possible to update email with a duplicated value
  validates :email, uniqueness: true, on: :create

  # it will be possible to create the record with a non-numerical age
  validates :age, numericality: true, on: :update

  # the default (validates on both create and update)
  validates :name, presence: true
end
-------------------------------------------------------

==4 Strict Validations
También puede especificar validaciones para que sean estrictas y ejecutar ActiveModel::StrictValidationFailed cuando el objeto no es válido.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :name, presence: { strict: true }
end

Person.new.valid?  # => ActiveModel::StrictValidationFailed: Name can't be blank
-------------------------------------------------------

También existe la posibilidad de pasar una excepción personalizada a la opción :strict.

[source, ruby]
-------------------------------------------------------
class Person < ActiveRecord::Base
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end

Person.new.valid?  # => TokenGenerationException: Token can't be blank"
-------------------------------------------------------
